#### Leader选举

##### 选举原则

leader是从集群中所有服务器中选择出来的一个服务器，leader对客户端发送过来的写请求进行排序，并将其生成事务，分发给follower执行。

为了保证一个集群中只会有一个leader，从而不会造成脑裂问题(两个leader).所以必须集群数量能够交错在一起，也就是说至少获取过半数的投票才能够当选leader。

##### 选举过程

每个服务器启动的时候状态为LOOKING状态，开始选举或者在集群中查找一个leader节点，如果leader节点存在，这个服务器会与leader节点进行通信。

如果集群中节点没有leader，那么就会开始进行leader选举，如果当前服务器选举为leader，那么将状态变更为leader，并向其他节点发出广播，其他节点变更状态为follower。

投票是根据节点标识符`sid`以及最近执行事务的id`zxid`决定的. 考虑到恢复时候需要最小的恢复时间，所以`zxid`最大的当选leader,如果一样则选择`sid`最大的。

当follower与leader同步成功之后，才可以开始处理客户端的请求，其中写请求会路由给leader进行处理。

#### ZAB(状态更新广播协议)

follower接收到一个写请求之后，会把消息路由给leader，leader会探索式执行该请求。将执行结果按照事务的方式对状态信息进行广播。一个事务包含服务器变更需要的确切操作，当事务提交的时候，服务器会将这些变更反馈到数据树上。

zookeeper使用ZAB协议确保事务的正确提交。ZAB协议类似于2PL(两段式提交). 

##### ZAB 提交过程

1. leader向所有follower广播一条提议消息
2. 追随者收到提议消息之后，像leader发送一条ACK信息。通知leader已经接受提议。
3. 收到仲裁数量的服务器发送的确认消息之后，leader会通知事务进行提交操作(写入日志).

follow在做出ACK响应之前，会检查当前提议消息是否属于当前的leader，并确定提议消息与事务消息提交的顺序是否正确，如果正确则做出ACK。

##### 关于leader宕机的处理

leader宕机的时候，会组织进行下一次的leader选举，所以对于每个leader来说，都是有纪元(epoch)信息存在的。

#### 观察者的设计

观察者不同于follower，它不参与leader选举的过程，它仅仅通过INFORM消息提交的提议进行学习。由于INFORM信息是包含了正在被提交的提交消息。所以在进行事务提交的时候，观察者是会动作的。

这样的话观察者可以看成follower的横向扩展，可以提供读请求的响应。由于没有额外扩展follower，所以在仲裁上花费的时间较少。



