#### 嵌套循环(Nest Loop)

1. 嵌套循环的算法

   驱动表返回一行数据，通过连接列传值给被驱动表，驱动表返回多少行，被驱动表就要被扫描多少次

2. 被驱动表的处理

   嵌套循环被驱动表必须走索引。如果嵌套循环被驱动表的连接列没包含在索引中，那么被驱动表就只能走全表扫描，而且是反复多次全表扫描。当被驱动表很大的时候，SQL 就执行不出结果。

   嵌套循环被驱动表走索引只能走`INDEX UNIQUE SCAN`或者`INDEX RANGESCAN`。

   嵌套循环被驱动表不能走TABLE ACCESS FULL，不能走INDEX FULL SCAN，不能走INDEX SKIP SCAN，也不能走INDEX FAST FULL SCAN。

3. 被驱动表选择

   嵌套循环被驱动表的连接列基数应该很高。如果被驱动表连接列的基数很低，那么被驱动表就不应该走索引，这样一来被驱动表就只能进行全表扫描了，但是被驱动表也不能走全表扫描。

两表关联返回少量数据才能走嵌套循环。前面提到，嵌套循环被驱动表必须走索引，如果两表关联，返回100万行数据，那么被驱动表走索引就会产生100万次回表。回表一般是单块读，这个时候SQL性能极差，所以两表关联返回少量数据才能走嵌套循环。

所以嵌套循环适合OLTP查询，不适合OLAP查询。

> HINT 书写的要求
>
> 在书写HINT的时候，如果表有别名，HINT中一定要使用别名，否则HINT不生效；如果表没有别名，HINT中就直接使用表名。

##### 两表进行外连接，驱动表只能是主表

因为嵌套循环需要传值，主表传值给从表之后，如果发现从表没有关联上，直接显示为NULL即可；但是如果是从表传值给主表，没关联上的数据不能传值给主表，不可能传NULL给主表，所以两表关联是外连接的时候，走嵌套循环驱动表只能固定为主表。

#### Hash Join

两表关联返回少量数据应该走嵌套循环，两表关联返回大量数据应该走HASH连接。

两表等值关联，返回大量数据，将较小的表选为驱动表，将驱动表的“select列和join列”读入PGA中的work area，然后对驱动表的连接列进行hash运算生成hash table。当驱动表的所有数据完全读入PGA中的work area之后，再读取被驱动表（被驱动表不需要读入PGA中的work area），对被驱动表的连接列也进行hash运算，然后到PGA中的work area去探测hash table，找到数据就关联上，没找到数据就没关联上。

所以，Hash Join只支持等值连接，且HASH连接的 被驱动表 只需要扫描一次。

> 驱动表太大可能出现的问题: 
>
> 当驱动表太大、PGA不能完全容纳驱动表时，驱动表就会溢出到临时表空间，进而产生磁盘 HASH连接，这时候HASH连接性能会严重下降。

##### Hash Join优化

1. 尽量避免书写select * from....语句，将需要的列放在select list中，这样可以减少驱动表对PGA的占用，避免驱动表被溢出到临时表空间
2. 将临时表空间创建在SSD上或者RAID 0上，加快临时数据的交换速度。
3. 如果驱动表比较大，比如驱动表有4 GB，可以开启并行查询至少parallel(4)，将表拆分为至少4份，这样每个并行进程中的work area能够容纳1 GB数据，从而避免驱动表被溢出到临时表空间。
4. 表拆分

#### Sort Merge Join

排序合并连接主要用于处理两表非等值关联。

##### 排序合并连接算法

两表关联，先对两个表根据连接列进行排序，将较小的表作为驱动表。然后从驱动表中取出连接列的值，到已经排好序的被驱动表中匹配数据，如果匹配上数据，就关联成功。

驱动表返回多少行，被驱动表就要被匹配多少次，这个匹配的过程类似嵌套循环，但是嵌套循环是从被驱动表的索引中匹配数据，而排序合并连接是在内存中（PGA中的work area）匹配数据。(Nest Loop在没有建立索引的情况下，是通过迭代查询的方式进行的，而排序合并通过二分查找进行)。

##### 排序合并连接的优化

1. 如果两表关联是等值关联，走的是排序合并连接，我们可以将表连接方式改为HASH连接。如果两表关联是非等值关联，比如>，>=，<，<=，<>，这时我们应该先从业务上入手，尝试将非等值关联改写为等值关联。

#### 笛卡尔连接(Cartesian Join)

两个表关联没有连接条件的时候会产生笛卡儿积，这种表连接方式就叫笛卡儿连接。

在多表关联的时候，两个表没有直接关联条件，但是优化器错误地把某个表返回的Rows算为1行（注意必须是1行），这个时候也可能发生笛卡儿连接。

##### 笛卡尔积优化

1. 首先应该检查表是否有关联条件，如果表没有关联条件，那么应该询问开发与业务人员为何表没有关联条件，是否为满足业务需求而故意不写关联条件。
2. 其次应该检查离笛卡儿连接最近的表是否真的返回1行数据，如果返回行数真的只有1行，那么走笛卡儿连接是没有问题的，如果返回行数超过1行，那就需要检查为什么Rows会估算错误，同时要纠正错误的Rows。纠正错误的Rows之后，优化器就不会走笛卡儿连接了。
3. 使用HINT禁止笛卡尔积。

#### 标量子查询(Scalar Subquery)

当一个子查询介于select与from之间，这种子查询就叫标量子查询。标量子查询类似一个天然的嵌套循环，而且驱动表固定为主表。

尽量避免使用标量子查询，假如主表返回大量数据，主表的连接列基数很高，那么子查询中的表会被多次扫描，从而严重影响SQL性能。如果主表数据量小，或者主表的连接列基数很低，那么这个时候我们也可以使用标量子查询，但是记得要给子查询中表的连接列建立索引。

当SQL里面有标量子查询，我们可以将标量子查询等价改写为外连接，从而使它们可以进行HASH连接。

> 为什么不使用内连接?
>
> 因为标量子查询是一个传值的过程，如果主表传值给子查询，子查询没有查询到数据，这个时候会显示NULL。如果将标量子查询改写为内连接，会丢失没有关联上的数据。

#### 半连接(Semi Join)

两表关联只返回一个表的数据就叫半连接。半连接一般就是指的in和exists。

in和exists有时候也可以等价地改写为内连接。

> 半连接中主表和子表的关系:
>
> 1. 如果半连接中主表属于1的关系，子表（子查询中的表）属于n的关系，我们在改写为内连接的时候，需要加上GROUP BY去重。注意：这个时候半连接性能高于内连接。
> 2. 如果半连接中主表属于n的关系，子表（子查询中的表）属于1的关系，我们在改写为内连接的时候，就不需要去重了。注意：这个时候半连接与内连接性能一样。
> 3. 如果半连接中主表属于n的关系，子表（子查询中的表）也属于n的关系，这时我们可以先对子查询去重，将子表转换为1的关系，然后再关联，千万不能先关联再去重。

#### 反连接(Anti Join)

两表关联只返回主表的数据，而且只返回主表与子表没关联上的数据，这种连接就叫反连接。反连接一般就是指的not in和not exists。所以在将not exists等价改写为not in的时候，要注意null。一般情况下，如果反连接采用not in写法，我们需要在where条件中剔除null。

两表关联如果是外连接，要改变HASH连接的驱动表必须使用swap_join_inputs。

#### Filter

如果子查询（in/exists/not in/not exists）没能展开，在执行计划中就会产生FILTER，FILTER类似嵌套循环，FILTER的算法与标量子查询一模一样。

FILTER的算法与标量子查询一模一样，驱动表都是固定的（固定为主表），不可更改。