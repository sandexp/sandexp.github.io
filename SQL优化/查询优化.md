#### 查询执行的过程

##### 总体流程

1. 客户端发送一条消息给服务端
2. 服务器先检查查询缓存，如果查询缓存中有本次请求的结果，则直接返回结果，否则3
3. 服务器通过对`sql`进行解析，校验，优化，执行获得执行结果，并将结果返回给客户端.

##### 查询优化处理

MySQL优化器可以进行下述优化过程:

1. 重新定义表的关联顺序

2. 外连接转换为内连接

   识别可以转换为内连接的外连接表达式

3. 等价变换规则

   合并或者移除一些恒(不)等表达式

4. 优化`count,min,max`函数

   使用索引第一项/最后一项来代表min/max函数(利用索引的性质).

5. 预估并转化为常数表达式

   如果表达式预估值为常数，则将其按照常数来进行处理。

6. 子查询优化

7. 提前终止查询

   当发现已经满足查询要求的时候，MySQL会终止向下继续迭代记录.

8. 等值传播

   如果两个列的值通过等式关联，MySQL可以把一个列的where条件转移到另一个列上

#### 特定类型查询优化

1. count优化

   count函数时用来计算非空列值的数目，如果count目标是表达式的话，则表示表达式非空的逻辑。所以，如果要计算行数，则使用`count(*) `或者`count(1)`即可.

   当然如果数据量比较大的情况，且允许一定的统计误差，可以使用近似值来估计。

   比如，可以使用EXPLAIN的优化器估算一个近似值，这个过程不需要执行器去执行，执行成本较低。

   此外，count一般使用在扫描大多数记录的情景下，如果要对其进行优化，可以依靠覆盖索引的方式进行处理。

2. 关联查询优化

   + 在关联表中的第二个表上创建索引字段即可，不需要重复创建
   + 保证group by 或者 order by表达式只涉及到一个表中的列，以保证索引可以使用的上(一个表多列即可使用索引合并或者覆盖索引)

3. 子查询优化

   + 尽量使用关联查询代替子查询

4. Group By优化

   对于分组指令Group By来说，当没有命中索引的时候，会通过临时表和文件排序的方式来做分组。可以使用查询HINT的方式，告知优化器数据的特征，从而提升查询性能。

   如果对关联查询做分组操作，那么使用具有标识性(选择性高)的字段作为标志改写, 得到的效果较好.

   如果Group By没有指定排序方式，那么默认会进行排序，所以如果对顺序性不做要求的话，使用order by null，取消默认的排序，性能会得到提升。

5.  Limit优化

   limit 分页操作一般需要给定偏移量和获取的数量，如果配合排序方式和对应的索引，性能会得到提高。

   优化分页查询操作的常用方式是建立一个覆盖索引，在偏移量越大的情况下，得到的性能提升越大。

6. UNION优化

   MySQL通过填充临时表的方式来执行UNION查询。

   除非是不需要获取去重的数据，否则建议使用UNION ALL来代替UNION，因为去重是一件开销较大的动作。

#### 优化器HINT

如果对优化器执行的结果不满意，可以使用HINT提示优化方向。常用的HINT如下:

1. `DELAYED`

   对insert或者replace操作有效，将数据插入到插入缓冲区中，直接返回。然后在表空闲时候，将数据真正的插入表中。

2. `STRAIGHT JOIN`

   放在select关键字之后，也可以放置在两个表之间。第一种做法是将所有的表按照语句出现的顺序进行关联，第二表则是固定前后两个表的顺序。 主要用于指定关联的顺序。

3. `SQL_SMALL_RESULT`或者`SQL_BIG_RESULT`

   提示优化器当前查询结果数据小/大, 让其采样合适的存储方式.

4. `SQL_CACHE`和`SQL_NO_CACHE`

   提示优化器当前查询结果是否需要存储到查询引擎中

5. `USE INDEX`,`IGNORE INDEX`和`FORCE INDEX`

   告知优化器是否使用索引，其中`force index`与`use index`不同的是，前者会告知优化器全部扫描的开销会远远大于索引扫描。