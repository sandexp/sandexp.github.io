#### 使用索引的好处

正常情况下对数据库进行查询，都需要对全表进行扫描，判断需不需要将行数据加入到结果集中。因此表中所有记录都需要进行处理。如果数据量很大，就会导致查询速度很慢。多余大量数据的表，例如数据仓库hive中的表，就需要引入分区处理了。

引入索引之后，我们可以清楚的知道需要获取的记录在存储的那个位置。这样就可以直接定位到记录了。

所以可以:

1. 减少服务器需要扫描的数据块数量
2. 避免排序操作和临时表生成的操作
3. 将随机IO变成顺序IO(B树键的顺序性)

#### 什么时候使用索引

并不是任何情况下，使用索引都比全表扫描性能来的好的，如果数据量比较小，或者是数据分布不均衡，会导致索引的性能要低于全表扫描，因为使用索引表的时候，是需要回表查询记录位置的。如果不能精确定位，会导致回表次数增加。从而降低查询性能。所以我们需要了解数据分布的情况，数据分布可以使用选择性来定义。

#### 选择性的定义

索引选择性 指的是 不重复索引值占总记录数量的比率。这个值越大，则会在查询的时候过滤掉更多不需要的行数据。反之则会选择比较多的行数据，最差的情况下，索引的使用效果不如全表扫描。

对于BLOB,TEXT类型，则必须要使用前缀索引，否则占用存储太大。建立和查询索引结构开销和耗时增大。

#### 索引类型

##### B树索引

B树作为索引节点的存储结构, B树能够保证节点是按照key顺序排序的，所以适合范围查询，当然全值查询和前缀查询也是可以的。

##### B+树索引

作为B树的扩展，叶子节点存储的是记录信息，所以可以通过对叶子节点遍历(B+树维护了叶子节点构成的链表，使得遍历的时间复杂度为O(n)).

##### 哈希索引

通过哈希算法将记录映射到存储空间中，一般情况下不允许重复，即一个bucket中只能有一条记录的引用。如果允许重复值的话，就将记录按照链表的格式组织在bucket中。

哈希索引对于全值查询响应迅速，但是不能使用前缀查询和范围查询。比较适合数据仓库中的维度表设计。

#### 常用的索引

##### 单列索引

对于普通的单列索引来说，如果这个索引列参与了表达式运算，或者函数运算，那么这个索引就会失效，实际上使用的还是全表扫描。所以使用索引的时候，需要注意，尽可能将索引列单独放置。

##### 前缀索引

如果索引列过长，或者索引列的部分就可以满足很好的选择性，那么我们用这一部分来作为索引键即可。

##### 多列索引

一般情况下单独对多个在where条件中的字段建立索引，是不会达到预期的过滤效果的。因为这三个索引其实是建立了三个B树，这三棵树是独立的，所以达不到预期的过滤效果。可以考虑建立对应的覆盖索引。

`Mysql` 5.0之后引入了索引合并, 一定程度上可以解决多列索引优化效果问题。

##### 索引顺序的选择

一般情况下，进行`sql`查询的时候，是按照索引顺序进行过滤的，所以选择度越高的字段 索引顺序越靠前，达到的优化效果越好。

##### 聚簇索引

聚簇索引是一种存储形式，将B树索引和数据行保存在一个结构体中。

当表中存在有聚簇索引的时候，实际上行数据存储在索引的叶子节点中。聚簇表示的是数据行和相邻的键值信息紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只有一个聚簇索引. (使用覆盖索引可以模拟多个聚簇索引)

优势:

+ 数据访问块，因为数据行和索引存储在一起
+ 可以把相关数据存储在一起

缺点:

+ 更新聚簇索引，通常意味着需要调整底层存储，会导致页分裂的情况
+ 可能导致全表扫描变慢，尤其是页分裂导致数据存储不连续的情况

##### 覆盖索引

覆盖索引是针对于where条件中的谓词条件设计的，索引不仅可以快速的获取数据，还可以快速的获取数据行的信息。只需要回表查询到行的行编号，就可以定位到行所处的位置，这个操作叫做回表。从回表查询到row_id之后，需要通过随机IO的方式读取该行数据。如果回表多了，则随机IO次数也多了，查询效率就降低了。

所以将一个索引包含需要查询的所有字段，这样就可以精确的获取数据信息，从而不需要进行回表了。

那么覆盖索引的好处有哪些呢?

1. 索引表记录远远小于数据表记录，筛选效果好
2. 索引顺序是按照列顺序排列的，在IO调度上都是朝着一个方向移动，开销比完全随机IO低
3. 可以实现多个聚簇索引，这样就不用多次查询

