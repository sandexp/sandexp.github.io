#### 消费者与消费者组

消费者组负责订阅主题，消费者从属于消费者组，用于消费主题中的分区。其中一个分区对应于一个消费者。当消费者足够多的时候会出现部分消费者没有消费的分区的情况，起始是消耗系统资源的行为。

##### 消息投递的方式

1. 点对点通信

   生产者将消息发送到队列中，消费者从队列中获取消息进行消费动作。

2. 发布订阅模式

   生产者将消息发布到主题中，消费者负载定义主题信息。主题使得生产者和消费者解耦。

##### 消息消费的过程

1. 创建消费者实例
2. 消费者订阅主题
3. 通过轮询的方式拉取消息进行消费
4. 提交消息位移
5. 关闭消费者实例

一个消费者可以订阅一个或者多个主题，Kafka提供了集合订阅的方式subscribe, 正则表达式的订阅方式, 指定分区的订阅方式assign三种方式.

其中使用subscribe的定义方式具有对消费者自动再平衡的功能，而assign方式没有这个功能。

#### 消息消费的过程

Kafka消费是基于拉模式的，由消费者客户端去对主题进行轮询，获取主题上的消息信息。消费者线程通过调用轮询调用poll方法，来获取这些消息信息。

消费者消费的每条消息的类型为`ConsumerRecord`, poll 方法返回的是消息的集合，可以使用迭代器进行访问。

消费者端的消息描述如下:

```java
public class ConsumerRecord<K,V> {
    private final String topic;
    private final int partition;
    private final long offset;
    private final long timestamp;
    private final TimestampType timestampType;
    private final int serializedKeySize;
    private final int serializedValueSize;
    private final Headers headers;
    private final K key;
    private final V value;
    private volatile Long checksum;
}
```

#### 位移提交

对于Kafka的分区来说，每条消息都有其分区内偏移量，而消费者消费到的位置（分区内相对位置）也可以成为位移。每次Kafka消费记录之后，就需要移动这个偏移量，来指示当前读取的位置。

旧版本的Kafka中，位移信息存储在Zookeeper中，新版本的Kafka将位移信息存储在主题`__consumer_offsets`中. 这个主题用于持久化位移量信息。



##### 位移的自动提交和手动提交

Kafka的位移自动提交时每个一定的时间，就会将位移信息提交上去，这就会导致在提交之前如果副本宕机的话，会导致之前消费的数据重新消费的问题。

且业务对于一条消息消费成功与否，是在于下游是否入库成功，如果成功，才算真正的消费成功。这种情况下，就需要进行手动提交，控制提交的时机。

##### 同步提交和异步提交

1. 同步提交

   拉取最新的位移进行提交，只要没有发生不可恢复的错误，就会阻塞到消费过程完毕。

2. 异步提交

   异步提交不会阻塞主线程的执行，可以设置回调函数来确定消费完毕时候的执行逻辑。

#### 消费行为的控制

#### 消费位移的指定

当消费者在Kafka中找不到当前分区的消费位移的时候，就会根据用户指定的参数去定位，如果使用的是lastest方式，则会从分区末尾开始消费，使用earliest，则会从分区开头开始消费，配置为none则会在没有位移信息的情况下抛出异常。

同时Kafka提供了seek方法，给与用户在指定分区内定位到指定偏移量的位置处进行消费。

#### 消费者的再均衡

再平衡是指分区使用权从消费者A转向消费者B，再平衡是消费者端负载均衡的实现。再均衡的过程中，消费者时无法继续消费数据的。分区分配给新的消费者时，消费者当前状态也会丢失。

#### 消费者拦截器

消费者拦截器在消费者调用消费逻辑和提交位移逻辑的时候会进行拦截功能的执行。

#### 多线程消费的实现

1. 每个线程实例化一个消费者对象
2. 使用共享的offset来进行提交，每个线程处理完毕之后将位移量写入到offset中，需要进行并发控制

