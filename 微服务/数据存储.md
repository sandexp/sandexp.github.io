#### 分布式数据库架构

随着时间和业务的发展，分布式架构数据库中的数据量增长是不可控的，库和表中的数据会越来越多，随之带来的是更高的磁盘、IO、系统开销，甚至性能上的瓶颈。当数据库单表达到千万级别后，SQL性能会开始下降。

##### 分库

分库的含义：根据业务需要将原库拆分成多个库，通过降低单库的大小来提高单库的性能。常见的分库方式有两种——垂直分库和水平分库。

1. 垂直分库

   垂直分库是根据业务进行划分的，将同一类业务相关的数据表划分在同一个库中。

   例如将原库中有关商品的数据表划分为一个数据库，将原库中有关订单的数据表划分为另一个数据库。

2. 水平分库

   水平分库是按照一定的规则对数据库进行划分。每个数据库中各个表的结构相同，数据存储在不同的数据库中。

##### 分表

根据业务需要将大表拆分成多个子表，通过降低单表的大小来提高单表的性能。

常见的分表方式有两种：垂直分表和水平分表。

1. 垂直分表

   垂直分表就是将一个大表根据业务功能拆分成多个分表。例如原表可根据业务分成基本信息表和详细信息表等。

2. 水平分表

   水平分表是按照一定的规则对数据表进行划分。每个数据表的结构相同，数据存储在多个分表中。

##### 水平切分

水平分表或者水平分库都属于水平切分的方式。在真实业务场景中，强烈建议分库，而不是分表。

因为分表依然共用一个数据库文件，仍然有磁盘IO的竞争，而分库能够很容易地将数据迁移到不同的数据库实例，甚至不同的数据库机器上，扩展性更好。

常用的水平切分方式有两种：范围法和哈希法。

##### 垂直切分

垂直分库或者垂直分表都属于垂直切分。在开发过程中，往往根据业务对数据进行垂直切分时，一般要考虑属性的“长度”和“访问频度”两个因素：

1. 长度较短、访问频率较高的放在一起。
2. 长度较长、访问频度较低的放在一起。

这是因为数据库会以行为单位将数据加载到内存里，在内存容量有限的情况下，长度短且访问频度高的属性，内存能够加载更多的数据，命中率会更高，磁盘IO会减少，数据库的性能会提升。



#### 分布式缓存架构

缓存是分布式架构中非常重要的一部分，通常用它来降低数据库压力，提升系统整体性能，缩短访问时间。

##### Redis与Memcache选型

Memcache和Redis是分布式架构中常用的Key-Value缓存。满足下述几点，选择Redis更加合适。

1. 复杂的数据结构，例如Value是哈希、列表、集合、有序集合等，会选择Redis。
2. Memcache无法满足持久化的需求，只能选择Redis。
3. Redis原生支持集群功能，可以实现主从复制、读写分离。
4. Memcache的Value最大为1 MB。如果存储的Value很大，就只能使用Redis。

优选Memcache的情景:

纯KV、数据量非常大、并发量非常大的业务使用Memcache更适合

1. Memcache使用预分配内存池的方式管理内存，能够省去内存分配时间。Redis则是临时申请内存空间，可能导致碎片。
2. Memcache把所有的数据存储在物理内存里。Redis有自己的`VM`机制，理论上能够存储比物理内存更多的数据，当数据超量时会引发Swap，把冷数据刷到磁盘上。
3. Memcache使用多线程，主线程监听，Worker子线程接受请求执行读写。Redis使用单线程，虽无锁冲突，但难以利用多核的特性提升整体吞吐量。

##### 进程内缓存

所谓进程内缓存，就是将一些数据缓存在站点或者服务的进程内。进程内缓存的实现载体，最简单的可以是一个带锁的Map，或者使用第三方库，例如Guava。

进程内缓存可以存储的数据类型多样，比如存储JSON数据、HTML页面、对象等。与没有缓存相比，进程内缓存的好处是，数据读取不再需要访问后端，例如数据库。

#### 微服务解耦

微服务之间的调用，如果调用方关注执行的结果，我们一般会使用HTTP或者RPC等技术来实现同步调用。如果调用方不关心执行结果，却仍然使用同步RPC调用，就会引发上下游服务极大的耦合与瓶颈。

这时，我们可以采用消息队列来实现服务之间的异步调用。

> 适合于异步调用的业务:
>
> 用户发博客、发微信、发帖子、点赞和评论等功能,这些业务都不需要关心中间的结果。

#### Session

##### session 与 cookie

HTTP是一种无状态协议，服务器没有办法仅仅从网络连接上就知道访问者的身份，为了解决这个问题，就诞生了Cookie技术。

1. cookie工作原理

Cookie实际上是一小段文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用Response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。

服务器检查该Cookie，以此来辨认用户的状态。

> Cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须携带这些Cookie，如果Cookie很多，就无形增加了客户端与服务端的数据传输量，而Session的出现正是用来解决这个问题的。

同一个客户端和服务端交互时，不需要每次都传回所有的Cookie值，只要传回一个ID，这个ID是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。

这样每个客户端就有了一个唯一的ID，客户端只要传回这个ID就行了，这个ID通常是`NANE`为`JSESIONID`的一个Cookie。

2. session工作原理

Session是服务器上的一种用来存放用户数据的类HashTable结构。

浏览器第一次发送请求时，服务器自动生成一个HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送到浏览器。

浏览器第二次发送请求会将前一次服务器响应的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。

##### session 一致性问题

在单机情况下，每次HTTP连接请求都能够正确路由到存储Session的对应Web服务器。但是在分布式情况下，如果每台服务器都把Session保存在自己的内存中，不同服务器之间就会造成数据不一致问题。

##### session 同步

1. session同步法

   Web服务之间相互同步Session，这样每个Web服务之间都包含全部的Session。缺点也是很明显的，Session的同步需要数据传输，占内网带宽，有一定的时间延迟。

2. 基于`nginx`的`ip_hash`策略

   每个用户请求按访问`IP`的Hash结果分配，这样每个访客固定访问一个后端服务器，可以解决Session的问题

   使用基于Nginx的`ip_hash`策略，只需要更改Nginx配置，不需要修改应用代码，而且能够保持多台Web服务的负载是均衡的，同时可支持Web服务水平扩展。

   > 缺陷:
   >
   > 1. 如果Web服务重启，Session就会丢失，产生业务影响，例如部分用户需要重新登录
   > 2. 如果Web服务进行水平扩展，根据用户`IP`重新Hash后，Session就会重新分布，导致一部分用户路由到不正确的Session。

3. session集中统一管理

   通过缓存或者数据库来存入和读取Session信息，集群应用共享，达到Session统一管理的目标。

   这种方法是目前企业中最为常用的一种方法，Web服务重启或者扩容都不会导致Session丢失