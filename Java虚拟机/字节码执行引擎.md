#### 运行时栈帧结构

方法是Java虚拟机执行的最小单元，栈帧用于支持方法调用和方法背后的数据结构。

栈帧中存储了方法的局部变量表，操作数栈，动态链接以及返回地址信息等。在Java源码编译的时候，栈帧的大小就被确定下来了，并存储在方法区的code属性中。所以栈帧的大小与运行时数据无关。下面介绍栈帧的各个部分：

1. 局部变量表

   局部变量表的最小存储单元为槽，一个槽可以存储一个基本数据类型或者引用数据类型

2. 操作数栈

   操作数栈的最大深度在code属性中已经定义了，32位数据占用一个栈容量。

3. 动态链接

   每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用， 这样引用主要是用来进行动态链接的。

4. 返回地址

   返回的方式包括正常执行完毕返回和异常返回。

#### 方法调用

方法调用与方法的执行不是一个概念，方法调用主要是解决方法需要选择哪个版本的方法进行执行。某些调用在类加载期间就可以决定，有些调用需要在运行期间才能决定。

##### 解析

方法调用的目标方法在Class文件中是一个符号引用，在类加载阶段就可以确定的方法，即可以转化为直接引用进行使用。这种方法调用称作为解析。

常用的解析的方法调用为，静态方法的调用，类私有方法的调用，实例构造器方法以及父类方法。此外final修饰的方法也可以在类加载阶段确定。这些方法统一称作非虚方法。主要调用了invokespecial或者invokestatic的字节码指令。

##### 分派

1. 静态分派

   依赖静态类型决定方法版本的分派动作，称作静态分派，这个操作是在编译期完成的。典型应用就是方法的重载。

2. 动态分派

   运行期执行invokevirtual指令时从操作数栈获取元素的类型，根据元素类型，选择合适的方法版本。这个就是方法重写的实质。这种运行期决定方法版本的行为称作动态分派。

3. 单分派和多分派

   方法接受者和方法参数称作方法的宗量。如果基于一个宗量进行方法版本选择，则称作单分派，否则称作多分派。

   静态分派属于单分派，动态分派属于多分派。

4. 动态分派的实现

   动态分派执行的频次比较高，所以每次操作影响系统性能，故而需要维护一个**虚方法表**，用于寻找合适的方法版本的入口地址。

   如果子类没有重写父类方法，则父类子类的入口地址是一致的，反之则不一致。同时同样的方法签名，在父类表和子类表的索引位置应当相同，方便寻址。

#### 动态语言功能的支持

动态语言的支持提供了对`lamada`表达式的支持。

##### invoke包

invoke包提供了使用方法句柄确定调用的目标方法的方式，有了方法句柄之后，Java也可以使用函数指针的概念了。

##### invokedynamic指令

每次调用invokedynamic的位置叫做动态调用点，这个位置处查找的就不是方法表，而是动态调用点的表。在这个表中可以获得引导方法，方法类型，方法名称三个参数。

引导方法固定指向invoke包下的CallSite参数, 获取CallSite参数之后，最终会应用到目标方法。