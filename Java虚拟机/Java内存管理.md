#### 判断对象存活的方法

##### 引用计数法

在对象中添加一个引用计数器，当有一个地方引用它的时候，计数值加一，当有个地方释放它的时候，计数器减一，当计数值为零的时候，释放对象的内存。

##### 可达性分析法

以`GC ROOT`为起始点，遍历对象图，能够到达的地方表示引用存在，不可到达的对象需要进行回收。

1. `GC ROOT`的选择

作为`GC ROOT`起始点的可以是静态变量，常量，以及线程栈帧中的变量。

2. 对象释放的过程

一个对象在对象图遍历中不可到达时，不会立即被回收，如果这个对象值得去调用finalize方法进行释放的时候，这个对象才真的需要被释放。

释放的时候，不会立即调用finalize方法，而是将对象引用放置到一个队列中，之后由虚拟机启用的一个低优先级的线程去进行对象内存的释放。

3. 对象引用的特性

新版本的Java中，对引用存在的生命周期做出了更加细粒度的划分，可分为强引用，软引用，弱引用，虚引用四种类型。

+ 强引用：通用意义上的引用，需要通过对象图，历经虚拟机的两次筛选才可以被释放
+ 软引用：当系统内存不足的时候，虚拟机会释放软引用的内存，来保证程序正常运行
+ 弱引用：下一次垃圾回收的时候，一定会将弱引用回收
+ 虚引用：没有生命周期的概念，不可使用虚引用构造对象，设置虚引用仅仅是在相关对象在被回收的时候受到一个系统通知

#### 垃圾回收算法

##### 分代理论

1. 强分代理论：大多数对象都是朝生夕灭的 （新生代区域特性）
2. 弱分代理论：熬过多次垃圾回收的对象越难消亡 （老年代区域特性）

对于新生代区域，使用强分代理论，使用标记复制法的效果要好于标记清除法，由于大多数对象需要释放，所以只需要将少数存活的对象拷贝到新存储空间即可，开销小，且不会产生内存碎片的问题。

对于老年代对象，使用弱分代理论，使用标记清除法，或者标记整理法，进行对象内存的回收，标记整理法由于涉及到内存块的移动，所以时间开销大，会造成stop the world的情况，所以CMS收集器使用的是以标记清除法为主，当使用内存足够大的时候，才会采用标记整理，对内存碎片进行整理，方便大对象的分配。

3. 跨代理论假说：不同区域的对象之间存在引用，占比在同代引用中少

跨代的两个对象，应当是同时存在，同时消亡的，存在有新生代因此晋升到老年代的情况。由于跨代引用占比比较小，所以变量老年代对象，检查是否存在跨代引用是不合理的，所以需要一个专门的数据结构，记录新生代到老年代的映射关系，这里称作**记忆集**，记忆集存储的是老年代的内存块，查找引用时，只会查找这一部分内存块的内容。

##### 标记清除法

1. 标记需要被回收的内存块
2. 回收被标记的内存块

优点：实现简单，响应快速

缺点：会产生内存碎片

##### 标记复制法

将整个内存区域分割成两个相等的部分

1. 在区域1中标记需要被回收的内存块
2. 将存活的内存块按照顺序移动到区域2中
3. 将区域1的所有内存块清空

优点：响应迅速，不会产生内存碎片

缺点：可利用内存区域减半

##### 标记整理法

在标记清除法的基础上，对存活的内存块进行紧凑操作

优点：不会产生内存碎片

缺点：紧凑操作会产生时间上的开销，会造成stop the world的现象

#### HotSpot 垃圾回收的实现

##### 根节点枚举

根节点枚举的时候需要获取当前虚拟机中对象图的一致性快照，所以不可避免的需要暂停用户线程。HotSpot虚拟机设计了OopMap的数据结构，可以快速定位对象的物理位置。

##### 安全点和安全区域

1. 安全点

每条指令都会改变OopMap，所以需要选取一个标准，这个标准称作安全点。线程采用主动式中断的方式在安全点处挂起(轮询到中断标记为true的时候挂起)。

安全点一般选择在跳转指令处 或者 循环指令处。

2. 安全区域

当线程在安全点处处于阻塞或者睡眠状态，则无法响应中断。所以这里的安全点需要拉长，这里称作安全区域。

线程离开安全区域必须要等待到根节点枚举完成之后。

##### 记忆集与卡表

为了解决跨代引用，需要扫描老年代全部内存区域的问题，引入了记忆集的概念。

记忆集是从非收集区域指向收集区域的集合，当新生代对象需要进行回收的时候，会检查这个记忆集，是否对于的老年代区域存在有引用，如果有，则不会被标记。这个小的内存区域，称作为**卡表**。

只有卡表内包含有收集区对象的引用，则卡表的标记位置位，表示需要对当前卡表进行扫描。

##### 写屏障

其他分代区域对象引用了本区域对象，对应的卡表就应当标记为脏，变脏应当发生在引用赋值的时候。HotSpot通过写屏障维护卡表状态。

写屏障就是引用赋值动作的AOP切面，赋值前叫做写前屏障，赋值后叫做写后屏障。

虚拟机在写后屏障的位置处，对卡表状态进行维护。

##### 并发情况下的可达性分析

并发扫描的时候会出现对象消失的问题，即当对象图中插入一条或者多条黑色到白色节点的引用，或者删除全部从灰色到白色的引用。 会导致原本黑色对象标记为白色对象。（即对象需要被回收）

针对上述问题，可以通过**增量更新**或者**原始快照**的方式去处理。

1. 增量更新

   当插入黑色到白色节点引用的时候，会将这条插入记录下来，并发扫描结束之后，再以这个黑色节点为起点进行扫描。

2. 原始快照(STAB)

   当灰色对象需要删除到白色对象的引用的时候，会将其记录下来，当并发扫描结束之后，以灰色对象为起点进行扫描。

#### 常用的垃圾收集器

##### CMS垃圾收集器

1. CMS垃圾回收过程

   + 初始标记

     暂停用户线程，进行根节点枚举

   + 并发标记

     多线程并发变量`GC ROOT`,标记不可到达的对象

   + 重新标记

     使用增量更新的方式，重新检查并发标记阶段是否存在有"对象消失"的问题，并重新标记需要清除的对象

   + 并发清除

     对标记删除的对象进行清理(使用标记清除法)

2. CMS的局限性

   + 对CPU敏感

     对于CPU少的服务器来说，执行CMS垃圾回收需要一定的核心数，这就导致用户线程的核心数减少，使得用户线程跑得慢。

   + 无法清除浮动垃圾

     在垃圾回收的过程中，同时伴有垃圾的产生，这一部分垃圾的回收无法在这一轮回收过程中清理

##### G1垃圾收集器

G1 垃圾收集器是面向局部内存区域的 基于Region的垃圾收集器。从堆内内存中构成**回收集**。

Region作为回收的基本单元，可以充当新生代，老年代，也设定了Humongous 区域，用于专门存储大对象(大对象只要超出region一般大小即可)。

1. 跨代引用的处理

   Region中维护自己的记忆集信息，记忆集中执行引用了自己的Region信息。

2. 并发标记阶段引用关系的处理方式

   通过原始快照(STAB)的方式处理并发标记阶段，引用变化的问题。

   同时Region设计了两个TAMS，用于给新创建的对象进行内存分配。

3. 如何建立可靠的停顿模型

   G1收集器会根据每个Region的回收耗时，每个Region记忆卡中的脏卡数量等统计信息，选择回收性价比最高的进行回收。

4. 垃圾回收过程

+ 初始标记

  标记`GC ROOT`能够直接关联到的对象，同时修改TAMS指针的信息，方便创建对象时候的内存分配。

+ 并发标记

  从`GC ROOT`开始对堆中对象进行扫描，找出需要进行回收的对象。 处理完毕之后，需要对第一次并发标记过程中标记删除的对象进行引用变动的校验（通过STAB记录处理）。

+ 最终标记

  暂停用户线程，处理并发阶段结束后留下的少量STAB记录。

+ 筛选回收

  更新Region的统计信息，根据回收价值进行排序，构成回收集。把需要回收的Region的存活对象拷贝到空的Region中，这个过程是由收集器线程并行完成的。

##### ZGC垃圾收集器

1. 设计目的

   在不影响吞吐量的情况下，降低垃圾收集时的停顿时间

2. Region设计

   ZGC收集器的Region是动态的，大小不是固定的。

3. ZGC并发整理算法的实现

   ZGC收集器采用了染色指针技术，通过在64位地址信息上，一般情况下，有18位不做寻址的功能，剩余46位中使用其中4位作为染色标记，也就是说一个64位的指针信息，使用4位作为标记符。（缺陷是寻址范围降为原来的1/16）。

   同时带来的问题是多重映射的问题，不同的虚拟存储地址可能得到的物理地址是一个(16个相同的，因为4位做了标记符)。

4. ZGC的运行过程

   + 并发标记

     并发的对象图进行可达性分析，ZGC的标记是在指针的标志位上进行设置的。

   + 并发预备重分配

     根据特定的查询条件得出本次垃圾回收需要回收的region，并得出统计信息, 将这些region组成重分配集。

     重分配集中的对象会被转移到新的region中，并且更换指针信息，叫做指针治愈。

   + 并发重分配

     将重分配集中region的存活对象转移到新的region中。

     重分配region维护一个新旧region的转换表，对象通过转换表转移到新的region中。当有一个新的对象加入旧region时，会被重定向到新region中。同时还需要修改指针信息，称作指针自愈。

   + 并发重映射

     并发的将旧对象映射到新对象的位置，这个过程合并在下一次垃圾回收的并发标记阶段。

#### 内存分配与回收策略

##### 对象分配区域选择

大多数对象优先分配在Eden区域，如果Eden区域空间不足，则触发`MinorGC`。

大对象直接进入老年代，因为大对象在Eden和Survivor区域拷贝开销很大。

根据弱分代理论，经历越多垃圾回收的对象越难消亡，所以需要设定一个分代年龄参数作为进入老年代的标准，且每次垃圾回收过程中活下来，分代年龄加一。

同时，考虑到老年代空间大小的问题，当达到某个分代年龄（小于给定的阈值）。对象的内存大小达到了Survivor空间的一般以上，也需要直接移动到老年代。

##### 空间分配担保

发生MinorGC之前，需要检查老年代最大可用连续内存是否大于新生代所有对象空间，如果是，则MinorGC安全。

否则需要检查当前情况下是否允许空间担保失败，如果允许，会在这种情况下尝试一次MinorGC，否则就是进行一次FullGC。

