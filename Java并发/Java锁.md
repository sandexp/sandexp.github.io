#### Lock锁

Java SE 5之后提供了Lock接口, 在synchronized提供的功能基础上, 支持中断/超时获取锁的功能.

#### AQS

##### AQS的结构

使用一个int类型的成员变量来表示状态，通过内置的FIFO的队列来完成资源获取线程的排队工作。对于同步状态的修改，AQS提供了`getState(),setState(int newState),compareAndSetState(int expect,int update)`，它们保证状态的修改是安全的。

##### AQS的实现分析

AQS提供的主要方法主要分为三类, 独占锁获取和释放同步状态，共享锁获取和释放同步状态，查询同步队列的等待线程情况。

首先实现AQS需要的是一个同步队列。

1. 同步队列

   + 当线程获取同步状态失败的时候，会将线程信息包装成一个节点信息，插入到同步队列中。

   + 当线程释放同步状态的时候，会唤醒队列头部的线程，使其继续获取同步状态。
   + 首节点在释放同步状态之后会唤醒后续节点，后续节点会成为新的首节点。

2. 独占式同步状态的获取

   + 同步状态获取
   + 构造节点
   + 插入同步队列，在同步队列中自旋
   + 依靠前驱线程唤醒，重新获取同步状态

3. 独占式同步状态的释放

   + 当前线程获取同步状态并且执行逻辑之后释放同步状态
   + 唤醒后续节点，使其获取同步状态(通过LockSupport唤醒)

4. 共享式同步状态的获取与释放

   + 调用tryAcquireShared方法，返回值大于等于0的时候，表示能够获取同步状态(获取大于等于0状态位)就表示成功获取同步状态
   + 释放同步状态之后会唤醒等待的线程，同时需要确保同步线程安全释放

5. 独占式超时同步状态的获取和释放

   + 获取成功的处理方式与独占式同步状态获取成功时一致，当获取失败的时候，会进行自旋，在规定时间内是线程等待，如果没有获得同步状态，则从等待逻辑中返回。

#### 重入锁

排他锁的一种，支持同一个线程多次获取同步状态，同时支持对公平锁和非公平锁的获取。

##### 重入锁的实现

1. 锁需要识别当前获取锁的线程与当前占有锁的线程是否为一个，如果是，则当前线程的引用计数加一
2. 当锁释放的时候，引用计数减一，当计数值为零的时候，是否线程以及相关资源

#### 读写锁

读写锁允许多个线程读取，但是如果有写线程的存在，则会阻塞读写线程的执行。

##### 读写锁的实现

1. 读写状态的设计

   AQS需要在同步状态(int值)上维护多个读取线程和一个写线程的信息，所以需要将32位int值进行拆分存储.(高低16位).

2. 写锁的获取和释放

   + 写锁是一个支持重入的排他锁，如果当前线程已经获取写锁，则增加引用计数
   + 写锁释放的时候，会将引用计数减一，当计数值为0的时候，按照独占式的方式释放同步状态

3. 读锁的获取和释放

   + 读锁是一个支持重入的共享锁，在没有写线程的存在情况下，读锁总是可以成功的获取，如果当前线程以及获取读写锁，则引用计数加一，如果其他线程获取写锁，则进入等待状态。

4. 锁降级

   把持住写锁，获取读锁，然后再释放掉写锁。

#### LockSupport

LockSupport是用于阻塞或者唤醒线程的一个工具，阻塞方法是以park开头，而唤醒线程以unpark开头。

#### Condition接口

Condition可以配合Lock锁实现等待/通知模式

##### Condition的实现分析

Condition的实现注意包括 等待队列，等待和通知.

+ 如果一个线程调用Condition.await(), 那么线程会释放锁，将相关信息包装成节点，放置到等待队列中。
+ 使用signal方法唤醒在等待队列中等待时间最长的节点，唤醒节点之前，将其移动到同步队列中。
+ 使用LockSupport唤醒该线程
+ 线程加入到获取同步状态的竞争中
+ 获取同步状态后，从await方法中返回

