#### volatile关键字

##### 共享变量可见性的保证

在指令前面加上Lock前缀.

Lock前缀可以:

+ 将处理器缓存行写入到系统内存中
+ 写回内存的操作, 会通过总线通知CPU, 将其对应位置缓存行设置为无效, 从而从主存读取数据

这样获取的数据都是同一份(写完后主存中的数据), 即表现为一致性.

#### sychronized关键字

##### sychronized关键字的实现

JVM基于进出Monitor对象实现代码块的同步. 编译时通过将monitorenter插入到同步代码块前面, 将monitorexit插入到同步代码块后面. 线程执行到monitorenter时候, 会尝试获取对象所对应monitor的所有权, 如果获取成功, 则成功进入同步代码块.

##### MarkWord格式

25 bit 用于存储对象的hashcode

4 bit 用于存储分代年龄(G C信息)

1 bit 表示偏向锁信息	如果标志位为1 则前面需要表示有执行所偏向线程的线程ID信息

2 bit 表示4中类型锁标志位

##### 锁升级过程

锁的状态为 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

##### 偏向锁

加锁不需要进行CAS, 也不会造成线程阻塞, 只需要在对象头中表示偏向锁信息即可.

偏向锁设计是处理竞争较少的情况下, 所以偏向锁释放需要线程参与竞争. 撤销时机选择在全局安全点. 执行的时候会暂停所有偏向锁线程, 检查持有偏向锁(参与竞争的线程)的线程是否存活, 如果没有存活, 则将状态修改为无锁. 否则修改偏向锁指向.

如果偏向锁获取失败, 则会选择使用CAS的方式替换MarkWord(轻量级锁).

##### 轻量级锁

使用CAS获取和释放锁.

1. 轻量级锁加锁

   进入同步代码块前, JVM会现在当前线程的栈帧中创建用于存储锁记录的空间. 将对象头中的MarkWord复制到锁记录中, 线程尝试使用CAS的方式将对象头的MarkWord替换为指向锁记录的指针. 如果成功则成功获取锁.

2. 轻量级锁释放

   使用CAS将Displaced Mark Word 替换到对象头中, 如果替换成功则解锁成功.

如果轻量级锁获取失败, 线程会自旋一段时间, 如果仍就失败则膨胀成重量级锁.

#### 原子操作的实现

##### CAS定义

CAS执行的时候需要一个旧值和一个新值. 当旧值没有发生变化的时候更新为新值.

##### 总线锁定

当一个CPU在总线上发起一个LOCK#信号的时候, 其他CPU的任何请求都被阻塞. 所以来说对于一个或者一些共享变量修改的原子性来说，锁定范围太广了. 开销太大.

##### 缓存锁定

CPU不在总线上发起LOCK信号, 而是在写回主存的时候修改缓存行的标记位, 使其无效, 进而组织多个CPU修改缓存行, 达到原子性的功能.

##### Java 关于原子性的实现

使用处理器提供的CMPXCHG, 自旋CAS就是通过循环执行CAS指令, 直到执行成功为止.

##### CAS的一些问题

1. ABA问题

   旧值在间隔CAS期间发生由A->B->A的变化过程, 错误的进行了CAS.

   解决方案: 假设版本号解决, 每次发生变化, 版本号值加一.

2. 循环CAS时间过长

   处理器支持pause指令

3. 只有一个变量可以CAS

   JDK 1.5开始提供了`AtomicReference`，用于支持对对象的CAS.

##### 使用锁实现原子操作