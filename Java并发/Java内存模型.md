#### happen-before 原则

JMM会限制影响执行结果的重排序

##### happen-before 定义

1. 如果一个操作happen-before另一个操作, 那么这个操作第一个操作的结果对第二个操作可见, 第一个操作执行顺序先于第二个(语义上)
2. 考虑到不改变执行结果的重排序存在, 实际执行的时候, 第一个操作可能晚于第二个操作执行. 但是语义保持不变.

##### happen-before 规则

1. 一个线程的每个操作happen-before之后的任意操作
2. 一个锁的解锁happen-before后面这个锁的加锁
3. 对于volatile域的写happen-before任意后续对这个域的读取操作
4. 传递性
5. 线程启动操作happen-before线程的任意执行逻辑
6. 线程的任意执行逻辑happen-before线程的join



#### as if serial 原则

**定义:** 不管如何进行重排序, 执行结果都不会发生变化.

**实现方式:** 编译器和处理器通过限制有数据依赖的相关操作重排序, 达成as if serial 语义.



#### 顺序一致性

**定义: ** 程序执行结果与程序在顺序一致性内存模型中执行的结果一致.

**特性:**

1. 一个线程中所有操作必须按照程序的顺序来执行
2. 在顺序一致性模型中, 一个操作必须原子执行 且 立即对所有线程可见.

顺序一致性模型中, 所有操作串行执行, 临界区中的代码可以进行重排序, 但是不可以逸出到临界区外面. 

没有成功同步的代码, 保证有最小的安全性(即保证值一定被赋值(包括零值)).



#### 锁的内存语义

##### 锁释放和获取的内存语义

1. 线程释放锁的时候, 会将本地内存的共享变量刷新到主存中.
2. 线程获取锁的时候, 会将缓存行置为无效, 从主存获取数据.

##### 锁内存语义的实现

获取锁的时候读取volatile变量, 释放锁的时候写入volatile变量. 是一个volatile读写的语义.

所不同的是, 公平锁是完整的volatile语义, 而非公平锁获取锁的时候是使用CAS修改volatile变量.

##### CAS内存语义

根据JDK官方的介绍，CAS实现了volatile读取和volatile写的语义, 也就是说编译器不能对CAS前面和CAS后面的操作进行重排序, 这就保证了原子性. 

同时CAS底层调用的是cmpxchg的C++代码, 会根据当前处理器的数目判断是否需要加lock前缀(锁总线). 来保证CAS操作的可见性. 同时会把写缓冲区的数据刷新到主存中. 起到了内存屏障的作用.



#### volatile内存语义

volatile对单个变量的读写, 与使用锁来同步一个普通变量是一致的. 因此具有锁的语义, 即volatile读取的时候可以看到上次volatile写入的结果.(可见性). 单个volatile读取具有原子性.

##### volatile的内存语义

1. 写入一个volatile变量的时候, 会将本地内存的共享变量刷新到主存中.
2. 读取一个volatile变量的时候, 会将对应缓存行设置为无效,从而从主存加载数据

##### volatile内存语义的实现

为了保证volatile的as if serial语义, 编译器和处理器禁止了部分重排序. 其中第二个操作为写操作和第一个操作为读都需要禁止重排序. 主要通过假设内存屏障来实现.

1. 在写操作前加上一个StoreStore屏障, 保证普通读写的可见性
2. 在写操作后面加上一个StoreLoad屏障, 避免后面的volatile读写重排序
3. 在读取操作后面加上一个LoadLoad屏障，禁止volatile读取和普通读取重排序
4. 在读取操作后面加上一个LoadStore屏障, 禁止volatile读取和普通写入重排序



#### final内存语义

##### final限制重排序规则

1. 构造器内对final域的写入, 与之后使用该对象引用进行赋值的操作不能重排序(否则final域没有初始化)

2. 初次读取一个包含final域的对象的引用, 与随后初次读取这个域, 不能重排序

   两个操作之间存在有间接依赖关系，因此编译器不会对其进行重排序，同样大多数处理器也不会进行重排序.

##### final域为引用类型

构造函数内对引用类型的初始化 和 使用该构造函数构造的对象被引用不能进行重排序.(导致final域没有初始化)