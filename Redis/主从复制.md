#### 主从复制功能实现

1. 读写分离

   主服务器只处理写请求，从服务器通过复制功能同步主服务器数据，只处理读请求，这样Redis的处理能力就得到了提示。

   此外可以通过主从复制来让主服务器免于进行持久化操作，只需要关闭主服务器的持久化，开启从服务器的持久化即可。

2. 数据容灾

   通过主从复制提升Redis服务的可靠性。由于从服务器与主服务器数据保持同步，一旦主服务器宕机，可以立即请求切换到从服务器，从而避免Redis被中断。

数据复制过程:

+ 从服务器向主服务器发送sync命令，请求同步数据。
+ 主服务器接收到sync命令，开始执行`bgsave`命令持久化数据到`RDB`文件中,持久化过程中，新命令会放置到缓冲区中。
+ 持久化数据完毕之后，主服务器将该`RDB`文件发送给从服务器, 将数据加载到内存.
+ 主服务器将缓冲区的命令 发送给 从服务器.
+ 当主服务器接收到写命令请求时候，会将命令Redis协议格式发送给从服务器，从服务器接受并处理主服务器发送过来的命令请求.

##### 部分重同步和完全重同步

从服务器会记录已经从主服务器接收到的数据(复制偏移量). 主服务器会维护一个复制缓冲区，记录自己执行且待发送给从服务器的命令，同时需要维护缓冲区第一个字节的复制偏移量。

从服务器使用psync向主服务器申请同步请求，同时告诉主服务器自己已经接收到了复制偏移量信息，主服务器判断该复制偏移量是否包含在复制缓冲区内部。如果包含，则不需要进行持久化，称为**部分重同步**，如果不包含则进行持久化，将写命令写入到复制缓冲区中，并重置复制偏移量，称为**完全重同步**。

1. 执行部分重同步的条件
   + RUN_ID相等
   + 主服务器切换导致主从切换

Redis 4.0 对主从复制提出了两点优化.

+ 持久化主从复制信息

  Redis服务器关闭的时候，将主从复制信息作为辅助字段存储在`RDB`中. Redis 服务器启动加载`RDB`文件时，恢复主从复制信息，重新同步主服务器时候携带。

+ 存储上一个主服务器复制信息

  当主服务器发生故障，自己成为新的主服务器时，便使用`replid2`和`second_replid_offset`存储之前主服务器的运行ID与复制偏移量.

#### 主从复制源码基础

首先先介绍一下Redis服务端的构造情况

```c++
struct redisServer {
    //服务器运行ID，对于从服务器来说，表示其主服务器的ID
    char replid[CONFIG_RUN_ID_SIZE+1];
    
    // 心跳包周期
    int repl_ping_slave_period;
    
    /**复制缓冲区,缓冲主服务器已经执行待发送给从服务器的命令*/
    char* repl_backlog;
    
    // 复制缓冲区的大小
    long long repl_backlog_size;
    
    // 复制缓冲区第一个字节的偏移量
    long long repl_backlog_off;
    
    // 复制缓冲区存储的命令请求数据长度
    long long repl_backlog_histlen;
    
    /*
    复制缓冲区最后一个字节的索引位置，向缓冲区写入数据的时候会从这个位置开始
    */
    long long repl_backlog_idx;
    
    // 从服务器列表
    list* slaves;
  	
    // 保持连接的从服务器数量
    int repl_good_slaves_count;
    
    int repl_min_slaves_to_write;
    
    int repl_min_slaves_max_lag;
    
    // master节点信息
    char* masterauth;
    char* masterhost;
    int masterport;
    client* master;
    
    int repl_server_stale_data;
    // 表示从服务是否只读
    int repl_slave_ro;
};
```

复制缓冲区是一个先进先出的循环队列，当写入数据量超过缓冲区大小时，旧的数据会被覆盖。因此随着每次数据的写入，需要更新缓冲区中数据第一个字节的复制偏移量`repl_backlog_off`，同时记录下次写入数据时的索引位置`repl_backlog_idx`，以及当前缓冲区中有效数据长度`repl_backlog_histlen`。

#### Slaver源码分析

用户调用`slaveof`指令启用主从同步, 需要主动连接主服务器请求同步数据。

从服务同步调用的是`replicaofCommand`函数, 执行这个函数并没有直接向主服务器发送同步连接，而是调用`serverCron`函数周期性地进行与主服务器进行同步数据的操作。

同时这个1函数还会发送心跳包，定时汇报自己的复制偏移量信息。

主动连接服务器包含如下几个步骤:

1. 连接socket
2. 发送ping请求包确认连接是否正确
3. 发起密码认证
4. 信息同步
5. 发送PSYNC命令
6. 接受 `RDB` 文件并载入
7. 连接建立完成，等待主服务器同步命令请求

上述过程，Redis设计了一系列状态机用于描述连接的过程。

#### Master源码分析

主服务器接受从服务器发送的同步请求的过程包括:

1. 连接socket
2. 发送ping请求包确认连接是否正确
3. 发起密码认证
4. 通过`REPLCONF`命令同步信息
5. 发送PSYNC命令
6. 接受`RDB`文件并载入
7. 连接建立完成

主服务器吃了psync指令的入口函数为`syncCommand`,主服务器首先判断是否可以执行部分重同步，如果可以，则返回复制缓冲区中的命令请求，更新有效从服务器数量。



##### 执行部分重同步的条件

1. 服务器的RUN_ID和复制偏移量必须合法
2. 复制偏移量必须包含在复制缓冲区

执行部分重同步的时候，主服务器将客户端加入到自己的slave列表中。

当主服务器判断需要执行完整重同步的时候，会fork子进程执行`RDB`持久化，将持久化数据发送给从服务器.

